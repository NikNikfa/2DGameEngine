
## 1. Introduction

MonoGame provides a simple but powerful system for accessing input from hardware devices such as the keyboard, mouse, and gamepad.  
The Input API exposes raw device states, leaving the interpretation and mapping of inputs to the engine or game logic.

Our engine builds an abstraction layer on top of the MonoGame Input API to support command mapping, input events, and integration with the Entity–Component–System (ECS) architecture.

This document describes the Input API provided by MonoGame and explains how it is integrated into the engine.

---

## 2. Purpose of the Input API

MonoGame’s Input API allows the engine to obtain the current state of all supported input devices during each update cycle. The API does not provide high-level behavior (such as action mapping or input events); these aspects are handled at the engine level.

MonoGame exposes the following device types:

1. Keyboard
    
2. Mouse
    
3. GamePad
    
4. Touch (mobile)
    

Our engine is primarily focused on keyboard, mouse, and gamepad input for desktop platforms.

---

## 3. Keyboard Input

MonoGame provides keyboard access through the `Keyboard` class.

### 3.1 Retrieving Keyboard State

The state of the keyboard is retrieved each frame using:

```csharp
KeyboardState state = Keyboard.GetState();
```

### 3.2 Querying Keys

`KeyboardState` allows the engine to check:

- Whether a key is currently pressed
    
- Whether a key is currently released
    
- The collection of all pressed keys
    

Example:

```csharp
if (state.IsKeyDown(Keys.Space))
{
    // Space bar is pressed
}
```

The engine polls keys every frame and maps them to higher-level commands.

---

## 4. Mouse Input

MonoGame provides mouse access through the `Mouse` class.

### 4.1 Mouse State

The current mouse state is retrieved using:

```csharp
MouseState mouse = Mouse.GetState();
```

### 4.2 Available Data

The mouse state includes:

- Cursor position (X, Y)
    
- Left, Right, Middle button states
    
- Scroll wheel value
    
- Horizontal scroll wheel (if supported)
    

Example:

```csharp
if (mouse.LeftButton == ButtonState.Pressed)
{
    // Left click
}
```

Our engine maps these raw states into actionable events or commands.

---

## 5. GamePad Input

MonoGame includes full support for Xbox-style controllers via the `GamePad` class.

### 5.1 Reading GamePad State

Each frame, the engine retrieves the controller state:

```csharp
GamePadState state = GamePad.GetState(PlayerIndex.One);
```

### 5.2 Available Data

GamePad input includes:

- Thumbsticks
    
- Triggers
    
- Directional pad
    
- Face buttons
    
- Shoulder buttons
    
- Start/Back system buttons
    
- Connection state
    

Example:

```csharp
if (state.Buttons.A == ButtonState.Pressed)
{
    // A button pressed
}
```

## 6. Timing and Update Behavior

MonoGame input APIs provide **instantaneous input state**.  
This means:

- No built-in buffering
    
- No events
    
- No differentiation between “just pressed” or “held”
    

The engine handles these higher-level concepts by:

1. Storing input states from the previous frame
    
2. Comparing them to current states
    
3. Detecting transitions such as:
    
    - KeyDown
        
    - KeyUp
        
    - Held
        
4. Emitting input events if required
    
5. Mapping raw input to actions using the Command Pattern
    

This separation is intentional and aligns with ECS architecture principles.

---

## 7. Integration With Our Engine

### 7.1 Raw Input Collection

During every `Update` cycle, our engine retrieves:

- KeyboardState
    
- MouseState
    
- GamePadState (optional)
    

### 7.2 Command Mapping

The engine converts raw input states into player or system actions using a custom **Input Command Mapping Layer**.  
Key → Command  
Mouse Button → Command  
GamePad Button → Command

Commands are represented as objects implementing an interface.
This allows the engine to support:

- Customizable controls
    
- Rebinding
    
- Clean separation between input and behavior
    

### 7.3 Input Events

The engine uses an internal Event System to broadcast:

- Key down
    
- Key up
    
- Mouse click
    
- Mouse move
    
- Scroll events
    
- GamePad button changes
    

These events can be subscribed to by gameplay scripts, UI components, or systems.

### 7.4 Integration With Systems

Input affects:

- ScriptSystem
    
- PlayerController components
    
- UI
    
- Scene transitions
    
- Debug functionality
    

Input never modifies game state directly; it only issues commands or events.

---

## 8. Supported Platforms

MonoGame’s Input API is fully cross-platform:

- Windows
    
- Linux
    
- macOS
    
- Android (touch)
    
- iOS (touch)
    
- Xbox controllers on all desktop platforms
    

The engine uses this API to ensure consistent input behavior across platforms.

---

## 9. Summary

MonoGame’s Input API provides direct access to hardware device states but leaves higher-level interpretation to the engine.  
Our engine uses this API to build a structured input architecture consisting of:

- Raw input polling
    
- State comparison and transition detection
    
- Command Pattern for input-to-action mapping
    
- Event broadcasting
    
- Integration with ECS and Scene systems
    

This layered approach provides flexibility, testability, and a clear separation of responsibilities between raw input, command mapping, and gameplay logic.